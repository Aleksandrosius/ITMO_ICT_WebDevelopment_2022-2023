{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022-23 \u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0435\u043d\u044f \u0437\u043e\u0432\u0443\u0442 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440. \u042f \u0441\u0442\u0443\u0434\u0435\u043d\u0442 \u0442\u0440\u0435\u0442\u044c\u0435\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u0444\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442\u0430 \u0418\u041a\u0422 \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0438\u0442\u0435\u0442\u0430 \u0418\u0422\u041c\u041e. \u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u041d\u0430 \u044d\u0442\u043e\u043c \u0441\u0430\u0439\u0442\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u043c \u043f\u043e Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0437\u0430 \u043e\u0441\u0435\u043d\u043d\u0438\u0439 \u0441\u0435\u043c\u0435\u0441\u0442\u0440. \u041a\u043e\u043c\u0430\u043d\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 mkdocs: mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"\u0417\u043d\u0430\u043a\u043e\u043c\u0441\u0442\u0432\u043e"},{"location":"#web-2022-23","text":"\u041f\u0440\u0438\u0432\u0435\u0442, \u043c\u0435\u043d\u044f \u0437\u043e\u0432\u0443\u0442 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440. \u042f \u0441\u0442\u0443\u0434\u0435\u043d\u0442 \u0442\u0440\u0435\u0442\u044c\u0435\u0433\u043e \u043a\u0443\u0440\u0441\u0430 \u0444\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442\u0430 \u0418\u041a\u0422 \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0438\u0442\u0435\u0442\u0430 \u0418\u0422\u041c\u041e.","title":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022-23"},{"location":"#_1","text":"\u041d\u0430 \u044d\u0442\u043e\u043c \u0441\u0430\u0439\u0442\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u043c \u043f\u043e Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0437\u0430 \u043e\u0441\u0435\u043d\u043d\u0438\u0439 \u0441\u0435\u043c\u0435\u0441\u0442\u0440.","title":"\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435"},{"location":"#mkdocs","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"\u041a\u043e\u043c\u0430\u043d\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 mkdocs:"},{"location":"labs/lab_1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 - \u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0441\u043e\u043a\u0435\u0442\u0430\u043c\u0438 \u0426\u0435\u043b\u044c \u041e\u0432\u043b\u0430\u0434\u0435\u0442\u044c \u043f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u043c\u0438 \u043d\u0430\u0432\u044b\u043a\u0430\u043c\u0438 \u0438 \u0443\u043c\u0435\u043d\u0438\u044f\u043c\u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 web-\u0441\u0435\u0440\u0432\u0435\u0440\u043e\u0432 \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u043e\u0432. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u041f\u041e Python 3.10, \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 Python: sys, socket. \u041f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0437\u0430\u0434\u0430\u043d\u0438\u0435: \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21161: \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0421\u0435\u0440\u0432\u0435\u0440 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. server.py import socket sock = socket . socket () sock . bind (( 'localhost' , 7777 )) sock . listen ( 1 ) clientSocket , addr = sock . accept () print ( 'connected:' , addr ) while True : data = clientSocket . recv ( 1024 ) data = data . decode ( 'utf-8' ) print ( data ) if not data : break clientSocket . send ( 'Hello, client' . encode ( 'utf-8' )) sock . close () client.py import socket sock = socket . socket () sock . connect (( 'localhost' , 7777 )) sock . send ( 'Hello, server' . encode ( 'utf-8' )) data = sock . recv ( 1024 ) sock . close () print ( data . decode ( 'utf-8' )) \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21162: \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. server.py import socket from math import sqrt def quadratic_equation ( a , b , c ): d = b ** 2 - 4 * a * c if d >= 0 : return f \" { ( - b + sqrt ( b ** 2 - 4 * a * c )) / 2 * a } \" , f \" { ( - b - sqrt ( b ** 2 - 4 * a * c )) / 2 * a } \" else : return \"No real roots\" def server (): sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( 'localhost' , 7778 )) sock . listen () conn , addr = sock . accept () print ( f \"Connected: { addr } \" ) a = \"\" b = \"\" c = \"\" result = \"\" while not result : while not a : conn . send ( 'a' . encode ( 'utf-8' )) data = conn . recv ( 1024 ) . decode ( 'utf-8' ) if data . isdigit (): a = float ( data ) while not b : conn . send ( 'b' . encode ( 'utf-8' )) data = conn . recv ( 1024 ) . decode ( 'utf-8' ) if data . isdigit (): b = float ( data ) while not c : conn . send ( 'c' . encode ( 'utf-8' )) data = conn . recv ( 1024 ) . decode ( 'utf-8' ) if data . isdigit (): c = float ( data ) result = quadratic_equation ( a , b , c ) conn . send ( str . encode ( f \"Result is { result } \" )) conn . close () if __name__ == \"__main__\" : server () client.py import socket def client (): sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( 'localhost' , 7778 )) print ( \"Quadratic equation solver\" ) a = \"\" while not a . isdigit (): a = input ( \"Insert 'a': \" ) b = \"\" while not b . isdigit (): b = input ( \"Insert 'b': \" ) c = \"\" while not c . isdigit (): c = input ( \"Insert 'c': \" ) while True : data = sock . recv ( 1024 ) . decode ( 'utf-8' ) if data == 'a' : sock . send ( a . encode ( 'utf-8' )) if data == 'b' : sock . send ( b . encode ( 'utf-8' )) if data == 'c' : sock . send ( c . encode ( 'utf-8' )) if data . startswith ( \"Result\" ): print ( data ) break if __name__ == \"__main__\" : client () \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21163: \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443. \u0412 \u043e\u0442\u0432\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 http-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 html-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. server.py import socket class MyServer : def __init__ ( self , host , port , name ): self . host = host self . port = port self . name = name self . server = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def serve_forever ( self ): try : self . server . bind (( self . host , self . port )) self . server . listen () while True : client , address = self . server . accept () self . serve_client ( client ) except KeyboardInterrupt : self . server . close () def serve_client ( self , client ): html = self . handle_request () self . send_response ( client , html ) client . close () @staticmethod def handle_request (): with open ( \"index.html\" , \"r\" ) as file : body = file . read () return body def send_response ( self , client , html ): client . sendall ( f 'HTTP/1.1 200 OK \\r\\n Content-Type: text/html; charset=utf-8 \\r\\n\\r\\n { html } ' . encode ()) if __name__ == '__main__' : MyServer ( '127.0.0.1' , 7779 , 'sample.com' ) . serve_forever () index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Task 3 </ title > </ head > < body > < h1 > Hi, there! </ h1 > < article > This is a random text for task 3 of Lab 1 in Web-programming course 2022-2023. Actually got no idea if someone is ever going to read this but anyway have a good day! </ article > </ body > </ html > \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21164: \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0441\u0430 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u043b\u043b\u043e\u0432. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. server.py import socket import threading class MyChat : def __init__ ( self , ip , host ): self . sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) self . sock . bind (( ip , host )) self . sock . listen () self . clients = {} # {client:alias} def broadcast ( self , message , alias ): for client in self . clients . keys (): client . send ( f \" { alias } : { message } \" . encode ()) def handle_client ( self , client ): while True : try : message = client . recv ( 1024 ) . decode () self . broadcast ( message , self . clients [ client ]) except : client . close () self . broadcast ( f ' { self . clients [ client ] } has left the chat...' . encode ( 'utf-8' )) self . clients . pop ( client ) break def receive ( self ): print ( \"Server is running\" ) while True : client , address = self . sock . accept () print ( f \" { str ( address ) } connected!\" ) client . send ( b \"What is your alias?\" ) alias = client . recv ( 1024 ) . decode () self . clients [ client ] = alias self . broadcast ( f \" { alias } has connected to the chat\" , \"Server\" ) thread = threading . Thread ( target = self . handle_client , args = ( client ,)) thread . start () def run ( self ): self . receive () if __name__ == \"__main__\" : MyChat ( \"127.0.0.1\" , 7780 ) . run () client.py import socket import threading class MyClient : def __init__ ( self , ip , port ): self . alias = \"\" self . sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) self . sock . connect (( ip , port )) def receive ( self ): while True : try : message = self . sock . recv ( 1024 ) . decode () if message == \"What's your alias?\" : self . sock . send ( self . alias . encode ()) else : print ( message ) except : print ( \"Error...\" ) self . sock . close () break def send ( self ): while True : message = input () self . sock . send ( message . encode ()) def start ( self ): receive_thread = threading . Thread ( target = self . receive ) receive_thread . start () send_thread = threading . Thread ( target = self . send ) send_thread . start () if __name__ == \"__main__\" : MyClient ( \"127.0.0.1\" , 7780 ) . start () \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21165: \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 web-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST http \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c\u0438 Python \u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442: \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 , \u043e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0432 \u0432\u0438\u0434\u0435 html-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. server.py import socket grades = {} class MyHTTPServer : def __init__ ( self , host , port ): self . host = host self . port = port def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) try : serv_sock . bind (( self . host , self . port )) serv_sock . listen () while True : conn , _ = serv_sock . accept () try : self . serve_client ( conn ) except Exception as e : print ( 'Fail' , e ) finally : serv_sock . close () def serve_client ( self , client ): try : req = self . parse_request ( client ) resp = self . handle_request ( req ) self . send_response ( client , resp ) except ConnectionResetError : client = None if client : client . close () def parse_request_line ( self , rfile ): line = rfile . readline () line = line . decode ( 'utf-8' ) return line . split () def parse_request ( self , conn ): rfile = conn . makefile ( 'rb' ) method , target , ver = self . parse_request_line ( rfile ) request = { 'data' : {}, 'method' : method } if '?' in target : request [ 'method' ] = 'POST' values = target . split ( '?' )[ 1 ] . split ( '&' ) for value in values : a , b = value . split ( '=' ) request [ 'data' ][ a ] = b return request def handle_request ( self , req ): if req [ 'method' ] == 'POST' : return self . handle_post ( req ) else : return self . handle_get () def handle_get ( self ): content_type = 'text/html; charset=utf-8' body = '<html><head><style></style></head><body>' body += '<form><label>Subject</label><input name=\"discipline\" /><br><br><label>Grade</label><input name=\"grade\"/><br><br><input type=\"submit\"></form>' for subject in grades : body += f '<div><span> { subject } : { grades [ subject ] } </span></div>' body += '</div></body></html>' body = body . encode ( 'utf-8' ) headers = [( 'Content-Type' , content_type ), ( 'Content-Length' , len ( body ))] return Response ( 200 , 'OK' , headers , body ) def handle_post ( self , request ): discipline = request [ 'data' ][ 'discipline' ] grade = request [ 'data' ][ 'grade' ] if discipline not in grades : grades [ discipline ] = [] grades [ discipline ] . append ( grade ) return self . handle_get () def send_response ( self , conn , resp ): rfile = conn . makefile ( 'wb' ) status_line = f 'HTTP/1.1 { resp . status } { resp . reason } \\r\\n ' rfile . write ( status_line . encode ( 'utf-8' )) if resp . headers : for ( key , value ) in resp . headers : header_line = f ' { key } : { value } \\r\\n ' rfile . write ( header_line . encode ( 'utf-8' )) rfile . write ( b ' \\r\\n ' ) if resp . body : rfile . write ( resp . body ) rfile . flush () rfile . close () class Response : def __init__ ( self , status , reason , headers = None , body = None ): self . status = status self . reason = reason self . headers = headers self . body = body if __name__ == '__main__' : serv = MyHTTPServer ( '127.0.0.1' , 7781 ) serv . serve_forever ()","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/lab_1/#no1-","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 - \u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0441\u043e\u043a\u0435\u0442\u0430\u043c\u0438"},{"location":"labs/lab_1/#_1","text":"\u041e\u0432\u043b\u0430\u0434\u0435\u0442\u044c \u043f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u043c\u0438 \u043d\u0430\u0432\u044b\u043a\u0430\u043c\u0438 \u0438 \u0443\u043c\u0435\u043d\u0438\u044f\u043c\u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 web-\u0441\u0435\u0440\u0432\u0435\u0440\u043e\u0432 \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u043e\u0432.","title":"\u0426\u0435\u043b\u044c"},{"location":"labs/lab_1/#_2","text":"Python 3.10, \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 Python: sys, socket.","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u041f\u041e"},{"location":"labs/lab_1/#_3","text":"","title":"\u041f\u0440\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0437\u0430\u0434\u0430\u043d\u0438\u0435:"},{"location":"labs/lab_1/#no1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0421\u0435\u0440\u0432\u0435\u0440 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043e\u0442\u0441\u044b\u043b\u0430\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb. \u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. server.py import socket sock = socket . socket () sock . bind (( 'localhost' , 7777 )) sock . listen ( 1 ) clientSocket , addr = sock . accept () print ( 'connected:' , addr ) while True : data = clientSocket . recv ( 1024 ) data = data . decode ( 'utf-8' ) print ( data ) if not data : break clientSocket . send ( 'Hello, client' . encode ( 'utf-8' )) sock . close () client.py import socket sock = socket . socket () sock . connect (( 'localhost' , 7777 )) sock . send ( 'Hello, server' . encode ( 'utf-8' )) data = sock . recv ( 1024 ) sock . close () print ( data . decode ( 'utf-8' ))","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21161:"},{"location":"labs/lab_1/#no2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0443 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. server.py import socket from math import sqrt def quadratic_equation ( a , b , c ): d = b ** 2 - 4 * a * c if d >= 0 : return f \" { ( - b + sqrt ( b ** 2 - 4 * a * c )) / 2 * a } \" , f \" { ( - b - sqrt ( b ** 2 - 4 * a * c )) / 2 * a } \" else : return \"No real roots\" def server (): sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( 'localhost' , 7778 )) sock . listen () conn , addr = sock . accept () print ( f \"Connected: { addr } \" ) a = \"\" b = \"\" c = \"\" result = \"\" while not result : while not a : conn . send ( 'a' . encode ( 'utf-8' )) data = conn . recv ( 1024 ) . decode ( 'utf-8' ) if data . isdigit (): a = float ( data ) while not b : conn . send ( 'b' . encode ( 'utf-8' )) data = conn . recv ( 1024 ) . decode ( 'utf-8' ) if data . isdigit (): b = float ( data ) while not c : conn . send ( 'c' . encode ( 'utf-8' )) data = conn . recv ( 1024 ) . decode ( 'utf-8' ) if data . isdigit (): c = float ( data ) result = quadratic_equation ( a , b , c ) conn . send ( str . encode ( f \"Result is { result } \" )) conn . close () if __name__ == \"__main__\" : server () client.py import socket def client (): sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( 'localhost' , 7778 )) print ( \"Quadratic equation solver\" ) a = \"\" while not a . isdigit (): a = input ( \"Insert 'a': \" ) b = \"\" while not b . isdigit (): b = input ( \"Insert 'b': \" ) c = \"\" while not c . isdigit (): c = input ( \"Insert 'c': \" ) while True : data = sock . recv ( 1024 ) . decode ( 'utf-8' ) if data == 'a' : sock . send ( a . encode ( 'utf-8' )) if data == 'b' : sock . send ( b . encode ( 'utf-8' )) if data == 'c' : sock . send ( c . encode ( 'utf-8' )) if data . startswith ( \"Result\" ): print ( data ) break if __name__ == \"__main__\" : client ()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21162:"},{"location":"labs/lab_1/#no3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443. \u0412 \u043e\u0442\u0432\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 http-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 html-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. server.py import socket class MyServer : def __init__ ( self , host , port , name ): self . host = host self . port = port self . name = name self . server = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) def serve_forever ( self ): try : self . server . bind (( self . host , self . port )) self . server . listen () while True : client , address = self . server . accept () self . serve_client ( client ) except KeyboardInterrupt : self . server . close () def serve_client ( self , client ): html = self . handle_request () self . send_response ( client , html ) client . close () @staticmethod def handle_request (): with open ( \"index.html\" , \"r\" ) as file : body = file . read () return body def send_response ( self , client , html ): client . sendall ( f 'HTTP/1.1 200 OK \\r\\n Content-Type: text/html; charset=utf-8 \\r\\n\\r\\n { html } ' . encode ()) if __name__ == '__main__' : MyServer ( '127.0.0.1' , 7779 , 'sample.com' ) . serve_forever () index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Task 3 </ title > </ head > < body > < h1 > Hi, there! </ h1 > < article > This is a random text for task 3 of Lab 1 in Web-programming course 2022-2023. Actually got no idea if someone is ever going to read this but anyway have a good day! </ article > </ body > </ html >","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21163:"},{"location":"labs/lab_1/#no4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0441\u0430 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0430\u043b\u043b\u043e\u0432. \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. server.py import socket import threading class MyChat : def __init__ ( self , ip , host ): self . sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) self . sock . bind (( ip , host )) self . sock . listen () self . clients = {} # {client:alias} def broadcast ( self , message , alias ): for client in self . clients . keys (): client . send ( f \" { alias } : { message } \" . encode ()) def handle_client ( self , client ): while True : try : message = client . recv ( 1024 ) . decode () self . broadcast ( message , self . clients [ client ]) except : client . close () self . broadcast ( f ' { self . clients [ client ] } has left the chat...' . encode ( 'utf-8' )) self . clients . pop ( client ) break def receive ( self ): print ( \"Server is running\" ) while True : client , address = self . sock . accept () print ( f \" { str ( address ) } connected!\" ) client . send ( b \"What is your alias?\" ) alias = client . recv ( 1024 ) . decode () self . clients [ client ] = alias self . broadcast ( f \" { alias } has connected to the chat\" , \"Server\" ) thread = threading . Thread ( target = self . handle_client , args = ( client ,)) thread . start () def run ( self ): self . receive () if __name__ == \"__main__\" : MyChat ( \"127.0.0.1\" , 7780 ) . run () client.py import socket import threading class MyClient : def __init__ ( self , ip , port ): self . alias = \"\" self . sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) self . sock . connect (( ip , port )) def receive ( self ): while True : try : message = self . sock . recv ( 1024 ) . decode () if message == \"What's your alias?\" : self . sock . send ( self . alias . encode ()) else : print ( message ) except : print ( \"Error...\" ) self . sock . close () break def send ( self ): while True : message = input () self . sock . send ( message . encode ()) def start ( self ): receive_thread = threading . Thread ( target = self . receive ) receive_thread . start () send_thread = threading . Thread ( target = self . send ) send_thread . start () if __name__ == \"__main__\" : MyClient ( \"127.0.0.1\" , 7780 ) . start ()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21164:"},{"location":"labs/lab_1/#no5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 web-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST http \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c\u0438 Python \u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442: \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 , \u043e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0432 \u0432\u0438\u0434\u0435 html-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. server.py import socket grades = {} class MyHTTPServer : def __init__ ( self , host , port ): self . host = host self . port = port def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) try : serv_sock . bind (( self . host , self . port )) serv_sock . listen () while True : conn , _ = serv_sock . accept () try : self . serve_client ( conn ) except Exception as e : print ( 'Fail' , e ) finally : serv_sock . close () def serve_client ( self , client ): try : req = self . parse_request ( client ) resp = self . handle_request ( req ) self . send_response ( client , resp ) except ConnectionResetError : client = None if client : client . close () def parse_request_line ( self , rfile ): line = rfile . readline () line = line . decode ( 'utf-8' ) return line . split () def parse_request ( self , conn ): rfile = conn . makefile ( 'rb' ) method , target , ver = self . parse_request_line ( rfile ) request = { 'data' : {}, 'method' : method } if '?' in target : request [ 'method' ] = 'POST' values = target . split ( '?' )[ 1 ] . split ( '&' ) for value in values : a , b = value . split ( '=' ) request [ 'data' ][ a ] = b return request def handle_request ( self , req ): if req [ 'method' ] == 'POST' : return self . handle_post ( req ) else : return self . handle_get () def handle_get ( self ): content_type = 'text/html; charset=utf-8' body = '<html><head><style></style></head><body>' body += '<form><label>Subject</label><input name=\"discipline\" /><br><br><label>Grade</label><input name=\"grade\"/><br><br><input type=\"submit\"></form>' for subject in grades : body += f '<div><span> { subject } : { grades [ subject ] } </span></div>' body += '</div></body></html>' body = body . encode ( 'utf-8' ) headers = [( 'Content-Type' , content_type ), ( 'Content-Length' , len ( body ))] return Response ( 200 , 'OK' , headers , body ) def handle_post ( self , request ): discipline = request [ 'data' ][ 'discipline' ] grade = request [ 'data' ][ 'grade' ] if discipline not in grades : grades [ discipline ] = [] grades [ discipline ] . append ( grade ) return self . handle_get () def send_response ( self , conn , resp ): rfile = conn . makefile ( 'wb' ) status_line = f 'HTTP/1.1 { resp . status } { resp . reason } \\r\\n ' rfile . write ( status_line . encode ( 'utf-8' )) if resp . headers : for ( key , value ) in resp . headers : header_line = f ' { key } : { value } \\r\\n ' rfile . write ( header_line . encode ( 'utf-8' )) rfile . write ( b ' \\r\\n ' ) if resp . body : rfile . write ( resp . body ) rfile . flush () rfile . close () class Response : def __init__ ( self , status , reason , headers = None , body = None ): self . status = status self . reason = reason self . headers = headers self . body = body if __name__ == '__main__' : serv = MyHTTPServer ( '127.0.0.1' , 7781 ) serv . serve_forever ()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u21165:"}]}