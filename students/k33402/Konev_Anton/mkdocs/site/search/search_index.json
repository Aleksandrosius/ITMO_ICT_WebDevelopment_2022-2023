{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022 \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u041a\u043e\u043d\u0434\u0440\u0430\u0442\u044c\u0435\u0432\u0430 \u0410\u043b\u0435\u043a\u0441\u0435\u044f K33412","title":"\u0417\u043d\u0430\u043a\u043e\u043c\u0441\u0442\u0432\u043e"},{"location":"#web-2022","text":"","title":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022"},{"location":"#k33412","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u041a\u043e\u043d\u0434\u0440\u0430\u0442\u044c\u0435\u0432\u0430 \u0410\u043b\u0435\u043a\u0441\u0435\u044f K33412"},{"location":"lr1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u0447\u0430 \u21161 server.py import socket , time sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( '127.0.0.1' , 9090 )) sock . listen ( 1 ) sock . setblocking ( False ) print ( \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d \\n \u0421\u0435\u0440\u0432\u0435\u0440 \u0436\u0434\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\" ) while True : try : clientsocket , address = sock . accept () data = clientsocket . recv ( 16384 ) udata = data . decode ( \"utf-8\" ) print ( udata ) HDRS = 'HTTP/1.1 200 OK \\r\\n Content-Type: text/html; charset=utf-8 \\r\\n\\r\\n ' msg = 'Hello, client' . encode ( 'utf-8' ) clientsocket . send ( HDRS . encode ( 'utf-8' ) + msg ) sock . close () break except socket . error : print ( \"\u0416\u0434\u0443\" ) time . sleep ( 3 ) except KeyboardInterrupt : sock . close () break client.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( '127.0.0.1' , 9090 )) sock . send ( b \"Hello, server \\n \" ) data = sock . recv ( 16384 ) res = data . decode ( 'utf-8' ) print ( res ) sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21162 server.py import numbers import socket , time sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( '127.0.0.1' , 9090 )) sock . listen ( 1 ) sock . setblocking ( False ) print ( \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d \\n \u0421\u0435\u0440\u0432\u0435\u0440 \u0436\u0434\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\" ) while True : try : clientsocket , address = sock . accept () data = clientsocket . recv ( 16384 ) numbers = data . decode ( \"utf-8\" ) numbers = numbers . split () answer = int ( numbers [ 0 ]) * int ( numbers [ 1 ]) answer = str ( answer ) . encode ( 'utf-8' ) clientsocket . send ( answer ) clientsocket . close () break except socket . error : print ( \"\u0416\u0434\u0443\" ) time . sleep ( 3 ) except KeyboardInterrupt : clientsocket . close () break client.py import socket str = input ( \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u0443 \u0438 \u0432\u044b\u0441\u043e\u0442\u0443 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430: \" ) str = str . encode ( 'utf-8' ) sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( '127.0.0.1' , 9090 )) sock . send ( str ) data = sock . recv ( 16384 ) res = data . decode ( 'utf-8' ) print ( f '\u041f\u043b\u043e\u0449\u0430\u0434\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 { res } ' ) sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21163 server.py import socket import time sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) host = '127.0.0.1' port = 9090 sock . bind (( host , port )) sock . setblocking ( False ) print ( \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d\" , host , port ) sock . listen ( 3 ) while True : try : clientsocket , ( client_host , client_port ) = sock . accept () print ( 'Got connection from' , client_host , client_port ) data = clientsocket . recv ( 16384 ) HDRS = 'HTTP/1.1 200 OK \\r\\n Content-Type: text/html; charset=utf-8 \\r\\n\\r\\n ' body = \"\"\" <html> <body> <h1>Hello world!</h1> </body> </html> \"\"\" response = HDRS + body clientsocket . send ( response . encode ( 'utf-8' )) clientsocket . close () break except socket . error : print ( \"\u0416\u0434\u0443\" ) time . sleep ( 3 ) except KeyboardInterrupt : clientsocket . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21164 server.py import socket from threading import Thread HOST = \"127.0.0.1\" PORT = 9090 clients = [] sock = socket . socket () sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) sock . bind (( HOST , PORT )) sock . listen ( 10 ) print ( f \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d { HOST } : { PORT } \" ) def listen_for_client ( people ): while True : try : message = people . recv ( 1024 ) . decode () except Exception as e : print ( f \"[!] \u041e\u0448\u0438\u0431\u043a\u0430: { e } \" ) clients . pop ( people ) else : message = message . replace ( \" \" , \": \" ) for client in clients : client . send ( message . encode ()) while True : client , ( port , host ) = sock . accept () print ( f \"\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d { port } : { host } .\" ) clients . append ( client ) thread = Thread ( target = listen_for_client , args = ( client ,)) thread . daemon = True thread . start () client.py import datetime import socket from threading import Thread HOST = \"127.0.0.1\" PORT = 9090 sock = socket . socket () sock . connect (( HOST , PORT )) print ( f \"\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d \u043a { HOST } : { PORT } \" ) name = input ( \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0432\u043e\u0451 \u0438\u043c\u044f: \" ) def listen_for_messages (): while True : message = sock . recv ( 1024 ) . decode () print ( \" \\n \" + message ) thread = Thread ( target = listen_for_messages ) thread . daemon = True thread . start () while True : text = input () if text . lower () == 'q' : break date_now = datetime . datetime . now () . strftime ( '%Y-%m- %d %H:%M' ) text = f ' { date_now } { name } { text } ' sock . send ( text . encode ()) sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21165 server.py import socket class MyHTTPServer : def __init__ ( self , host , port ): self . host = host self . port = port def serve_forever ( self ): sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( self . host , self . port )) sock . listen ( 5 ) while True : clientsocket , _ = sock . accept () self . serve_client ( clientsocket ) def serve_client ( self , clientsocket ): data = clientsocket . recv ( 16384 ) data = data . decode ( 'utf-8' ) target , method = self . parse_request ( data ) headers , body = self . parse_headers ( data ) resp = self . handle_request ( target , method , body ) if resp : self . send_response ( clientsocket , resp ) def parse_request ( self , data ): data = data . replace ( ' \\r ' , '' ) lines = data . split ( ' \\n ' ) method , target , protocol = lines [ 0 ] . split () return target , method def parse_headers ( self , data ): data = data . replace ( ' \\r ' , '' ) lines = data . split ( ' \\n ' ) i = lines . index ( '' ) headers = lines [ 1 : i ] body = lines [ - 1 ] return headers , body def handle_request ( self , target , method , body ): if target == \"/\" : if method == \"GET\" : resp = \"HTTP/1.1 200 OK \\n\\n \" with open ( 'index.html' ) as f : resp += f . read () return resp if method == \"POST\" : newbody = body . split ( '&' ) for a in newbody : if a . split ( '=' )[ 0 ] == 'subject' : subjects . append ( a . split ( '=' )[ 1 ]) if a . split ( '=' )[ 0 ] == 'mark' : marks . append ( a . split ( '=' )[ 1 ]) resp = \"HTTP/1.1 200 OK \\n\\n \" resp += \"<html><head><title>Journal</title></head><body>\" for s , m in zip ( subjects , marks ): resp += f \"<p> { s } : { m } </p>\" resp += \"</body></html>\" return resp def send_response ( self , clientsocket , resp ): clientsocket . send ( resp . encode ( 'utf-8' )) if __name__ == '__main__' : host = 'localhost' port = 9090 serv = MyHTTPServer ( host , port ) subjects = [] marks = [] try : serv . serve_forever () except KeyboardInterrupt : pass index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Journal </ title > </ head > < body > < form action = \"/\" method = \"post\" > < div > < label for = \"name\" > Subject: </ label > < input type = \"text\" id = \"name\" name = \"subject\" /> </ div > < div > < label for = \"mail\" > Mark: </ label > < input type = \"number\" id = \"mail\" name = \"mark\" /> </ div > < div > < input type = \"submit\" > </ div > </ body > </ html >","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lr1/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"lr1/#no1_1","text":"server.py import socket , time sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( '127.0.0.1' , 9090 )) sock . listen ( 1 ) sock . setblocking ( False ) print ( \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d \\n \u0421\u0435\u0440\u0432\u0435\u0440 \u0436\u0434\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\" ) while True : try : clientsocket , address = sock . accept () data = clientsocket . recv ( 16384 ) udata = data . decode ( \"utf-8\" ) print ( udata ) HDRS = 'HTTP/1.1 200 OK \\r\\n Content-Type: text/html; charset=utf-8 \\r\\n\\r\\n ' msg = 'Hello, client' . encode ( 'utf-8' ) clientsocket . send ( HDRS . encode ( 'utf-8' ) + msg ) sock . close () break except socket . error : print ( \"\u0416\u0434\u0443\" ) time . sleep ( 3 ) except KeyboardInterrupt : sock . close () break client.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( '127.0.0.1' , 9090 )) sock . send ( b \"Hello, server \\n \" ) data = sock . recv ( 16384 ) res = data . decode ( 'utf-8' ) print ( res ) sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21161"},{"location":"lr1/#no2","text":"server.py import numbers import socket , time sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( '127.0.0.1' , 9090 )) sock . listen ( 1 ) sock . setblocking ( False ) print ( \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d \\n \u0421\u0435\u0440\u0432\u0435\u0440 \u0436\u0434\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\" ) while True : try : clientsocket , address = sock . accept () data = clientsocket . recv ( 16384 ) numbers = data . decode ( \"utf-8\" ) numbers = numbers . split () answer = int ( numbers [ 0 ]) * int ( numbers [ 1 ]) answer = str ( answer ) . encode ( 'utf-8' ) clientsocket . send ( answer ) clientsocket . close () break except socket . error : print ( \"\u0416\u0434\u0443\" ) time . sleep ( 3 ) except KeyboardInterrupt : clientsocket . close () break client.py import socket str = input ( \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u0443 \u0438 \u0432\u044b\u0441\u043e\u0442\u0443 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430: \" ) str = str . encode ( 'utf-8' ) sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( '127.0.0.1' , 9090 )) sock . send ( str ) data = sock . recv ( 16384 ) res = data . decode ( 'utf-8' ) print ( f '\u041f\u043b\u043e\u0449\u0430\u0434\u044c \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 { res } ' ) sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21162"},{"location":"lr1/#no3","text":"server.py import socket import time sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) host = '127.0.0.1' port = 9090 sock . bind (( host , port )) sock . setblocking ( False ) print ( \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d\" , host , port ) sock . listen ( 3 ) while True : try : clientsocket , ( client_host , client_port ) = sock . accept () print ( 'Got connection from' , client_host , client_port ) data = clientsocket . recv ( 16384 ) HDRS = 'HTTP/1.1 200 OK \\r\\n Content-Type: text/html; charset=utf-8 \\r\\n\\r\\n ' body = \"\"\" <html> <body> <h1>Hello world!</h1> </body> </html> \"\"\" response = HDRS + body clientsocket . send ( response . encode ( 'utf-8' )) clientsocket . close () break except socket . error : print ( \"\u0416\u0434\u0443\" ) time . sleep ( 3 ) except KeyboardInterrupt : clientsocket . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163"},{"location":"lr1/#no4","text":"server.py import socket from threading import Thread HOST = \"127.0.0.1\" PORT = 9090 clients = [] sock = socket . socket () sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) sock . bind (( HOST , PORT )) sock . listen ( 10 ) print ( f \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d { HOST } : { PORT } \" ) def listen_for_client ( people ): while True : try : message = people . recv ( 1024 ) . decode () except Exception as e : print ( f \"[!] \u041e\u0448\u0438\u0431\u043a\u0430: { e } \" ) clients . pop ( people ) else : message = message . replace ( \" \" , \": \" ) for client in clients : client . send ( message . encode ()) while True : client , ( port , host ) = sock . accept () print ( f \"\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d { port } : { host } .\" ) clients . append ( client ) thread = Thread ( target = listen_for_client , args = ( client ,)) thread . daemon = True thread . start () client.py import datetime import socket from threading import Thread HOST = \"127.0.0.1\" PORT = 9090 sock = socket . socket () sock . connect (( HOST , PORT )) print ( f \"\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d \u043a { HOST } : { PORT } \" ) name = input ( \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0432\u043e\u0451 \u0438\u043c\u044f: \" ) def listen_for_messages (): while True : message = sock . recv ( 1024 ) . decode () print ( \" \\n \" + message ) thread = Thread ( target = listen_for_messages ) thread . daemon = True thread . start () while True : text = input () if text . lower () == 'q' : break date_now = datetime . datetime . now () . strftime ( '%Y-%m- %d %H:%M' ) text = f ' { date_now } { name } { text } ' sock . send ( text . encode ()) sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21164"},{"location":"lr1/#no5","text":"server.py import socket class MyHTTPServer : def __init__ ( self , host , port ): self . host = host self . port = port def serve_forever ( self ): sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( self . host , self . port )) sock . listen ( 5 ) while True : clientsocket , _ = sock . accept () self . serve_client ( clientsocket ) def serve_client ( self , clientsocket ): data = clientsocket . recv ( 16384 ) data = data . decode ( 'utf-8' ) target , method = self . parse_request ( data ) headers , body = self . parse_headers ( data ) resp = self . handle_request ( target , method , body ) if resp : self . send_response ( clientsocket , resp ) def parse_request ( self , data ): data = data . replace ( ' \\r ' , '' ) lines = data . split ( ' \\n ' ) method , target , protocol = lines [ 0 ] . split () return target , method def parse_headers ( self , data ): data = data . replace ( ' \\r ' , '' ) lines = data . split ( ' \\n ' ) i = lines . index ( '' ) headers = lines [ 1 : i ] body = lines [ - 1 ] return headers , body def handle_request ( self , target , method , body ): if target == \"/\" : if method == \"GET\" : resp = \"HTTP/1.1 200 OK \\n\\n \" with open ( 'index.html' ) as f : resp += f . read () return resp if method == \"POST\" : newbody = body . split ( '&' ) for a in newbody : if a . split ( '=' )[ 0 ] == 'subject' : subjects . append ( a . split ( '=' )[ 1 ]) if a . split ( '=' )[ 0 ] == 'mark' : marks . append ( a . split ( '=' )[ 1 ]) resp = \"HTTP/1.1 200 OK \\n\\n \" resp += \"<html><head><title>Journal</title></head><body>\" for s , m in zip ( subjects , marks ): resp += f \"<p> { s } : { m } </p>\" resp += \"</body></html>\" return resp def send_response ( self , clientsocket , resp ): clientsocket . send ( resp . encode ( 'utf-8' )) if __name__ == '__main__' : host = 'localhost' port = 9090 serv = MyHTTPServer ( host , port ) subjects = [] marks = [] try : serv . serve_forever () except KeyboardInterrupt : pass index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Journal </ title > </ head > < body > < form action = \"/\" method = \"post\" > < div > < label for = \"name\" > Subject: </ label > < input type = \"text\" id = \"name\" name = \"subject\" /> </ div > < div > < label for = \"mail\" > Mark: </ label > < input type = \"number\" id = \"mail\" name = \"mark\" /> </ div > < div > < input type = \"submit\" > </ div > </ body > </ html >","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21165"}]}